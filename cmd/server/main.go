package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"user_mgmt_go/internal/config"
	"user_mgmt_go/internal/handlers"
	"user_mgmt_go/internal/middleware"
	"user_mgmt_go/internal/repository"
	"user_mgmt_go/internal/utils"

	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	_ "user_mgmt_go/docs" // This will be generated by swag init
)

// @title User Management System API
// @version 1.0
// @description A comprehensive user management system with JWT authentication, role-based access control, and activity logging.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @host localhost:8080
// @BasePath /api

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

// @tag.name auth
// @tag.description Authentication endpoints

// @tag.name users
// @tag.description User profile management endpoints

// @tag.name admin
// @tag.description Admin-only endpoints for user management

// @tag.name logs
// @tag.description User activity logs endpoints

// @tag.name health
// @tag.description System health and monitoring endpoints

// Application holds all application dependencies
type Application struct {
	config            *config.Config
	server            *http.Server
	repoManager       *repository.RepositoryManager
	middlewareManager *middleware.MiddlewareManager
	handlerManager    *handlers.HandlerManager
	jwtManager        *utils.JWTManager
}

func main() {
	log.Println("üöÄ Starting User Management System...")

	// Initialize application
	app, err := initializeApplication()
	if err != nil {
		log.Fatalf("‚ùå Failed to initialize application: %v", err)
	}

	// Start server in a goroutine
	go func() {
		if err := app.start(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("‚ùå Failed to start server: %v", err)
		}
	}()

	// Wait for interrupt signal
	app.waitForShutdown()

	// Graceful shutdown
	if err := app.shutdown(); err != nil {
		log.Printf("‚ùå Error during shutdown: %v", err)
		os.Exit(1)
	}

	log.Println("‚úÖ Application stopped gracefully")
}

// initializeApplication sets up all application dependencies
func initializeApplication() (*Application, error) {
	// Load configuration
	cfg, err := config.LoadConfig(".")
	if err != nil {
		return nil, fmt.Errorf("failed to load configuration: %w", err)
	}

	// Set Gin mode based on configuration
	gin.SetMode(cfg.Server.GinMode)

	// Initialize JWT manager
	jwtManager := utils.NewJWTManager(cfg.JWT.Secret, cfg.JWT.Expiry)

	// Initialize repository manager (database connections)
	repoManager, err := repository.NewRepositoryManager(&cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize repository manager: %w", err)
	}

	// Initialize middleware manager
	middlewareManager := middleware.NewMiddlewareManager(&cfg, jwtManager, repoManager)

	// Initialize handler manager
	handlerManager := handlers.NewHandlerManager(jwtManager, repoManager, middlewareManager)

	// Create Gin router
	router := gin.New()

	// Setup routes and middleware
	handlerManager.SetupRoutes(router)
	handlerManager.SetupDocumentationRoute(router)

	// Setup Swagger documentation (always enabled in development)
	if cfg.Server.GinMode == "debug" {
		router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
		log.Println("üìö Swagger documentation enabled at /swagger/index.html")
	}

	// Create HTTP server
	server := &http.Server{
		Addr:           fmt.Sprintf("%s:%s", cfg.Server.Host, cfg.Server.Port),
		Handler:        router,
		ReadTimeout:    30 * time.Second,
		WriteTimeout:   30 * time.Second,
		IdleTimeout:    60 * time.Second,
		MaxHeaderBytes: 1 << 20, // 1MB
	}

	app := &Application{
		config:            &cfg,
		server:            server,
		repoManager:       repoManager,
		middlewareManager: middlewareManager,
		handlerManager:    handlerManager,
		jwtManager:        jwtManager,
	}

	log.Printf("‚úÖ Application initialized successfully")
	log.Printf("üìä Configuration loaded: %s mode", cfg.Server.GinMode)
	
	return app, nil
}

// start begins the HTTP server
func (app *Application) start() error {
	log.Printf("üåê Starting HTTP server on %s", app.server.Addr)
	log.Printf("üì° API documentation available at: http://%s/api/docs/routes", app.server.Addr)
	log.Printf("‚ù§Ô∏è  Health check available at: http://%s/health", app.server.Addr)
	
	if app.config.Server.GinMode == "debug" {
		log.Printf("üìö Swagger documentation available at: http://%s/swagger/index.html", app.server.Addr)
	}
	
	// Print available routes summary
	app.printRoutesSummary()

	return app.server.ListenAndServe()
}

// waitForShutdown waits for interrupt signals
func (app *Application) waitForShutdown() {
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	sig := <-quit
	log.Printf("üõë Received shutdown signal: %v", sig)
}

// shutdown gracefully stops the application
func (app *Application) shutdown() error {
	log.Println("üîÑ Initiating graceful shutdown...")

	// Create context with timeout for shutdown
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Shutdown HTTP server
	log.Println("üîÑ Shutting down HTTP server...")
	if err := app.server.Shutdown(ctx); err != nil {
		log.Printf("‚ùå Error shutting down HTTP server: %v", err)
		return err
	}

	// Close repository connections
	log.Println("üîÑ Closing database connections...")
	if err := app.repoManager.Close(); err != nil {
		log.Printf("‚ùå Error closing repository manager: %v", err)
		return err
	}

	// Close middleware manager
	log.Println("üîÑ Cleaning up middleware...")
	app.middlewareManager.Close()

	// Close handler manager
	log.Println("üîÑ Cleaning up handlers...")
	app.handlerManager.Close()

	return nil
}

// printRoutesSummary displays available API routes
func (app *Application) printRoutesSummary() {
	log.Println("üìã Available API Routes:")
	routes := app.handlerManager.GetRouteSummary()
	
	for category, endpoints := range routes {
		log.Printf("  üìÇ %s:", category)
		for _, endpoint := range endpoints {
			log.Printf("    %s %s - %s [%s]", 
				endpoint.Method, 
				endpoint.Path, 
				endpoint.Description, 
				endpoint.Auth,
			)
		}
	}
}

// initializeTestData creates test data in debug mode
func (app *Application) initializeTestData() error {
	if app.config.Server.GinMode == "debug" {
		log.Println("üå± Debug mode detected - seeding test data...")
		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		if err := app.repoManager.SeedTestData(ctx); err != nil {
			return fmt.Errorf("failed to seed test data: %w", err)
		}
		log.Println("‚úÖ Test data seeded successfully")
	}
	return nil
}

// validateConfiguration validates the application configuration
func validateConfiguration(cfg *config.Config) error {
	if cfg.JWT.Secret == "" || cfg.JWT.Secret == "your-super-secret-jwt-key" {
		return fmt.Errorf("JWT secret must be set and not use default value")
	}

	if len(cfg.JWT.Secret) < 32 {
		log.Println("‚ö†Ô∏è  Warning: JWT secret should be at least 32 characters for security")
	}

	if cfg.Database.Password == "" || cfg.Database.Password == "password123" {
		log.Println("‚ö†Ô∏è  Warning: Database password should be changed from default")
	}

	if cfg.Admin.Password == "" || cfg.Admin.Password == "admin123" {
		log.Println("‚ö†Ô∏è  Warning: Admin password should be changed from default")
	}

	return nil
}

// printBanner displays the application banner
func printBanner() {
	banner := `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    User Management System                        ‚ïë
‚ïë                         Version 1.0.0                           ‚ïë
‚ïë                                                                  ‚ïë
‚ïë  üîê JWT Authentication    üìä Async Logging    üõ°Ô∏è  Security       ‚ïë
‚ïë  üë• User Management      üîç Advanced Search   üìà Analytics       ‚ïë
‚ïë  üéØ Clean Architecture   üöÄ High Performance  ‚ö° Go + Gin        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`
	fmt.Print(banner)
}

// Enhanced main function with banner and validation
func init() {
	printBanner()
}

// Version information
var (
	Version   = "1.0.0"
	BuildTime = "unknown"
	GitCommit = "unknown"
)

// printVersionInfo displays version information
func printVersionInfo() {
	log.Printf("üì¶ Version: %s", Version)
	log.Printf("üïê Build Time: %s", BuildTime)
	log.Printf("üîó Git Commit: %s", GitCommit)
} 